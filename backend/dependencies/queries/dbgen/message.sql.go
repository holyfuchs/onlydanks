// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message.sql

package dbgen

import (
	"context"
	"time"
)

const addMessage = `-- name: AddMessage :one
INSERT INTO message.message (index, message, submit_time) VALUES ($1, $2, $3) 
ON CONFLICT (index, message) DO UPDATE SET submit_time = EXCLUDED.submit_time 
RETURNING id, index, message, submit_time
`

type AddMessageParams struct {
	Index      string
	Message    string
	SubmitTime time.Time
}

// AddMessage
//
//	INSERT INTO message.message (index, message, submit_time) VALUES ($1, $2, $3)
//	ON CONFLICT (index, message) DO UPDATE SET submit_time = EXCLUDED.submit_time
//	RETURNING id, index, message, submit_time
func (q *Queries) AddMessage(ctx context.Context, arg AddMessageParams) (MessageMessage, error) {
	row := q.db.QueryRow(ctx, addMessage, arg.Index, arg.Message, arg.SubmitTime)
	var i MessageMessage
	err := row.Scan(
		&i.ID,
		&i.Index,
		&i.Message,
		&i.SubmitTime,
	)
	return i, err
}

const addPubkey = `-- name: AddPubkey :one
INSERT INTO message.pubkey (pubkey, submit_time) VALUES ($1, $2) 
ON CONFLICT (pubkey) DO UPDATE SET submit_time = EXCLUDED.submit_time 
RETURNING pubkey, submit_time
`

type AddPubkeyParams struct {
	Pubkey     string
	SubmitTime time.Time
}

// AddPubkey
//
//	INSERT INTO message.pubkey (pubkey, submit_time) VALUES ($1, $2)
//	ON CONFLICT (pubkey) DO UPDATE SET submit_time = EXCLUDED.submit_time
//	RETURNING pubkey, submit_time
func (q *Queries) AddPubkey(ctx context.Context, arg AddPubkeyParams) (MessagePubkey, error) {
	row := q.db.QueryRow(ctx, addPubkey, arg.Pubkey, arg.SubmitTime)
	var i MessagePubkey
	err := row.Scan(&i.Pubkey, &i.SubmitTime)
	return i, err
}

const getMessagesByIndex = `-- name: GetMessagesByIndex :many
SELECT id, index, message, submit_time FROM message.message WHERE index = $1
`

// GetMessagesByIndex
//
//	SELECT id, index, message, submit_time FROM message.message WHERE index = $1
func (q *Queries) GetMessagesByIndex(ctx context.Context, index string) ([]MessageMessage, error) {
	rows, err := q.db.Query(ctx, getMessagesByIndex, index)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageMessage
	for rows.Next() {
		var i MessageMessage
		if err := rows.Scan(
			&i.ID,
			&i.Index,
			&i.Message,
			&i.SubmitTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPubkeysSince = `-- name: GetPubkeysSince :many
SELECT pubkey, submit_time FROM message.pubkey WHERE submit_time > $1 LIMIT 1000
`

// GetPubkeysSince
//
//	SELECT pubkey, submit_time FROM message.pubkey WHERE submit_time > $1 LIMIT 1000
func (q *Queries) GetPubkeysSince(ctx context.Context, submitTime time.Time) ([]MessagePubkey, error) {
	rows, err := q.db.Query(ctx, getPubkeysSince, submitTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessagePubkey
	for rows.Next() {
		var i MessagePubkey
		if err := rows.Scan(&i.Pubkey, &i.SubmitTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
