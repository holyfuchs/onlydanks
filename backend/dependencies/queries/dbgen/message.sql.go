// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message.sql

package dbgen

import (
	"context"
	"time"
)

const addBlobSubmission = `-- name: AddBlobSubmission :one
INSERT INTO message.blob_submission (index, message, pubkey) VALUES ($1, $2, $3) 
ON CONFLICT (index, message, pubkey) DO NOTHING 
RETURNING id, index, message, pubkey
`

type AddBlobSubmissionParams struct {
	Index   []byte
	Message []byte
	Pubkey  []byte
}

// AddBlobSubmission
//
//	INSERT INTO message.blob_submission (index, message, pubkey) VALUES ($1, $2, $3)
//	ON CONFLICT (index, message, pubkey) DO NOTHING
//	RETURNING id, index, message, pubkey
func (q *Queries) AddBlobSubmission(ctx context.Context, arg AddBlobSubmissionParams) (MessageBlobSubmission, error) {
	row := q.db.QueryRow(ctx, addBlobSubmission, arg.Index, arg.Message, arg.Pubkey)
	var i MessageBlobSubmission
	err := row.Scan(
		&i.ID,
		&i.Index,
		&i.Message,
		&i.Pubkey,
	)
	return i, err
}

const addMessage = `-- name: AddMessage :one
INSERT INTO message.blob (index, message, submit_time, needs_submission) VALUES ($1, $2, $3, $4) 
ON CONFLICT (index, message) DO UPDATE SET submit_time = EXCLUDED.submit_time, needs_submission = EXCLUDED.needs_submission 
RETURNING id, index, message, submit_time, needs_submission
`

type AddMessageParams struct {
	Index           []byte
	Message         []byte
	SubmitTime      time.Time
	NeedsSubmission bool
}

// AddMessage
//
//	INSERT INTO message.blob (index, message, submit_time, needs_submission) VALUES ($1, $2, $3, $4)
//	ON CONFLICT (index, message) DO UPDATE SET submit_time = EXCLUDED.submit_time, needs_submission = EXCLUDED.needs_submission
//	RETURNING id, index, message, submit_time, needs_submission
func (q *Queries) AddMessage(ctx context.Context, arg AddMessageParams) (MessageBlob, error) {
	row := q.db.QueryRow(ctx, addMessage,
		arg.Index,
		arg.Message,
		arg.SubmitTime,
		arg.NeedsSubmission,
	)
	var i MessageBlob
	err := row.Scan(
		&i.ID,
		&i.Index,
		&i.Message,
		&i.SubmitTime,
		&i.NeedsSubmission,
	)
	return i, err
}

const addPubkey = `-- name: AddPubkey :one
INSERT INTO message.pubkey (pubkey, submit_time) VALUES ($1, $2) 
ON CONFLICT (pubkey) DO UPDATE SET submit_time = EXCLUDED.submit_time 
RETURNING pubkey, submit_time
`

type AddPubkeyParams struct {
	Pubkey     []byte
	SubmitTime time.Time
}

// AddPubkey
//
//	INSERT INTO message.pubkey (pubkey, submit_time) VALUES ($1, $2)
//	ON CONFLICT (pubkey) DO UPDATE SET submit_time = EXCLUDED.submit_time
//	RETURNING pubkey, submit_time
func (q *Queries) AddPubkey(ctx context.Context, arg AddPubkeyParams) (MessagePubkey, error) {
	row := q.db.QueryRow(ctx, addPubkey, arg.Pubkey, arg.SubmitTime)
	var i MessagePubkey
	err := row.Scan(&i.Pubkey, &i.SubmitTime)
	return i, err
}

const getBlobSubmissions = `-- name: GetBlobSubmissions :many
SELECT id, index, message, pubkey FROM message.blob_submission
`

// GetBlobSubmissions
//
//	SELECT id, index, message, pubkey FROM message.blob_submission
func (q *Queries) GetBlobSubmissions(ctx context.Context) ([]MessageBlobSubmission, error) {
	rows, err := q.db.Query(ctx, getBlobSubmissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageBlobSubmission
	for rows.Next() {
		var i MessageBlobSubmission
		if err := rows.Scan(
			&i.ID,
			&i.Index,
			&i.Message,
			&i.Pubkey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByIndex = `-- name: GetMessagesByIndex :many
SELECT id, index, message, submit_time, needs_submission FROM message.blob WHERE index = $1
`

// GetMessagesByIndex
//
//	SELECT id, index, message, submit_time, needs_submission FROM message.blob WHERE index = $1
func (q *Queries) GetMessagesByIndex(ctx context.Context, index []byte) ([]MessageBlob, error) {
	rows, err := q.db.Query(ctx, getMessagesByIndex, index)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageBlob
	for rows.Next() {
		var i MessageBlob
		if err := rows.Scan(
			&i.ID,
			&i.Index,
			&i.Message,
			&i.SubmitTime,
			&i.NeedsSubmission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPubkeysSince = `-- name: GetPubkeysSince :many
SELECT pubkey, submit_time FROM message.pubkey WHERE submit_time > $1 LIMIT 1000
`

// GetPubkeysSince
//
//	SELECT pubkey, submit_time FROM message.pubkey WHERE submit_time > $1 LIMIT 1000
func (q *Queries) GetPubkeysSince(ctx context.Context, submitTime time.Time) ([]MessagePubkey, error) {
	rows, err := q.db.Query(ctx, getPubkeysSince, submitTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessagePubkey
	for rows.Next() {
		var i MessagePubkey
		if err := rows.Scan(&i.Pubkey, &i.SubmitTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeBlobSubmission = `-- name: RemoveBlobSubmission :exec
DELETE FROM message.blob_submission WHERE id = $1
`

// RemoveBlobSubmission
//
//	DELETE FROM message.blob_submission WHERE id = $1
func (q *Queries) RemoveBlobSubmission(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, removeBlobSubmission, id)
	return err
}
